\documentclass{acm_proc_article-sp}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{color}
\usepackage[utf8x]{inputenc}
\usepackage{parskip}

\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}

\begin{document}

\title{Access Control Policy Verification and Repairing in Alloy}

\numberofauthors{1}

\author{
\alignauthor Alexandr Murashkin, Ming Matthew Ma \\
       \affaddr{The David R. Cheriton School of Computer Science}\\
       \affaddr{University of Waterloo}\\
       \affaddr{Waterloo, ON, Canada}\\
       \email{m22ma, amurashk@uwaterloo.ca}
}
\date{6 December 2012}
\maketitle

\begin{abstract}


sdadds\cite{Kounga:2010:EXA:1894888.1894907}sdfdfs

Sensitive data are becoming available through the Web and other distributed protocols. This heightens the need to carefully control access to data. Control means not only preventing the leakage of data but also permitting access to necessary information. Access control requires authorization rules and constraints. To express access control policies, several languages,
such as XACML are used to specify which subjects can  access sets of resources
or services to perform specific actions. 

We develop a tool based on first order logic modeling to detect and visualize possible conflicts within sets of access control policies expressed in XACML. We first translate the model
into a relational first order logic language called Alloy, and then analyze interactions
and conflicts among access control policies using Alloy analyzer. We then proposes potential repairs to the user thorough user interface, and automatically apply the fixes specified by the user. It is proved that with our tool can automatically determine inconsistencies in user specified model, and recommend the user and apply the repair successfully. 

\end{abstract}

\category{D.2.4}{Software Engineering}{Software/Program Verification}[formal methods]
\category{H.5.2}{Information Interfaces and Presentation}{User Interfaces}[Graphical user interfaces (GUI)]

\terms{Computer Aided Verification, Access Control Policy, User Interface}

\keywords{Alloy, XACML, rule set, policy set, GUI} % NOT required for Proceedings

\section{Introduction}

Important data are increasingly available on-line through the Web and other distributed protocols. This heightens the need to carefully control access to data. Access control means not only preventing the leakage of data but also permitting access to necessary information. The key goal is that the right person can access right resource on the right time.

\subsection{Motivation}

Due to growing variety of access methods, central databases must now provide data in a
large number of different contexts, each governed by specific access-control policies. Selective access control is an important mechanism in distributed system security. It can be used in order to allow a user to access only certain information, for certain purposes, at certain times, or when he or she plays a certain role. Access control is enforced by mechanisms that need to be programmed by means of policies. An organization may have many such policies, which may have been established at different times, by different people, perhaps without a clear view of all the consequences. Inconsistencies can then exist in such sets of policies. 

While policy mechanisms may be able to solve inconsistencies at a higher level, users and administrators still need to be aware of them, because they may lead to unintended system behavior. For example, a policy may be added to prevent a certain access, however in fact the access is still allowed because of another policy of higher priority, or the new policy may prevent access of someone who should remain authorized. We will show in this paper that such inconsistencies can be detected and fixed by using our tools.

\subsection{Background}


\textbf{\emph{XACML for Access Control}}\\
XACML is an OASIS standard that defines an architecture, policies and messages within an access control system. XACML generally center around attributes; attributes describe subjects, actions, and resources. For example, faculty is a value for the attribute role, which describes the subject. The names of attributes, such as role are called attribute ID, while the values bound
to them are called attribute values  (such as Faculty). The fragment of an XACML policy designating Faculty as a role is shown below:\\

\begin{verbatim}
<SubjectMatch MatchId=''...:string-equal''>
  <AttributeValue DataType=''...string''>
     Faculty</AttributeValue>
   <SubjectAttributeDesignator 
      AttributeId=''role''
      DataType=''...string''
   </SubjectAttributeDesignator>
</SubjectMatch>
\end{verbatim}

A rule in XACML specifies which decision to take as a function of the attributes. The XACML takes in a request, names and values of a set of attributes, and makes an access-control decision on it based on the specified rules. A decision can be permit, deny, or not-applicable which indicates that the requests is not handled. 

The access control policies are stored as XML files, they are structured into rules, policies and policy sets. Several rules are grouped into policies and policies are grouped into
policy sets. Rules, policies and policy sets define a target which indicates their domain of applicability. A target specifies a set of attributes and their values that should match those
given by a request. For example, if there are two policies, the first one is applied when the subject is a student, the resource is the marks file and the action is printing, and the second policy is applied
when the subject is a professor, the resource is the marks file and the action is modification. If a request from a student to print the marks file comes to the policy enforcement point, the policy decision point will only select the first policy to make a decision.

\textbf{\emph{Alloy}}\\
Alloy is a modeling language based on relational first order logic. An Alloy model is a collection of constraints that describes a set of structure. Alloy's tool, the Alloy Analyzer, is a solver that takes the constraints of a model and finds structures that satisfy them. It can be used both to explore the model by generating sample structures, and to check properties of the model by generating counterexamples. 

To model structures, Alloy uses the concepts of signature and relation. A signature is a type in Alloy. It can be considered equivalent to a class in the object oriented paradigm since a signature can be instantiated. For example, we can define a abstract general signature Element like this:
 
 \begin{verbatim}
abstract sig Element {
         attributes : Attribute -> Value}
         {attributes in values}
sig Subject, Resource, Action extends Element{}
\end{verbatim}

A relation is a structure that relates signatures and their instances. Functions are special binary relations; they map each instance from the left signature to only one instance from the right signature (the function effect maps each rule to only one effect). Constraints are represented in Alloy by facts. A fact is a logical formula that always holds. Alloy uses first order logic in an ASCII format. We can also specify predicates that could be evaluated to return true or false and functions that could return signature instances. Alloy is able to automatically instantiate and evaluate predicates.

\subsection{Related work}

Regarding access control policy verification, there are several various related approaches.
\cite{Hughes:2008:AVA:1459278.1459282} proposes encoding XACML access control policies  ordering relations and then translation of them into SAT solver for verification. \cite{4258517} describes inconsistency checking in role-based access control policies (RBAC).  \cite{Fisler:2005:VCA:1062455.1062502} proposes Margrave - a great tool for access control policies (XACML and other formats) verification and change-impact analysis. \cite{Jackson:2000:AFR:357474.355063} proposes Alloy Analyzer as first-order logic verification tool (there is a corresponding book \cite{jackson:alloy}).

For Access control policy verification in Alloy: 
1) http://www.cs.ucsb.edu/~bultan/publications/tech-report04.pdf
2 - WE USE IT!! ) http://w3.uqo.ca/notere05/documents/logrippo.pdf, need a citation.

Regarding repairing XACML access control policies, it does not seem to be a lot of prior related work. Rather than that, \cite{Zhang:2004:SVA:1029133.1029141} offers access control policies verification in the language called RW and then synthesize verified specifications in XACML. \cite{Bravo:2007:RIX:1783534.1783545} considers another type of access control policies - XML write access control policies - offers repairs in case of that some actions can be simulated by multiple another actions. 

Regarding model repairing in general, \cite{Xiong:2009:SAM:1595696.1595757} proposed .... for i don't know what, need to read :) . \cite{Reder:2012:CRT:2351676.2351707} proposes repair trees for inconsistency solving in design models.

The proposed technique of repairing inconsistencies - sketching - was described in the thesis http://people.csail.mit.edu/asolar/papers/thesis.pdf .

Need to look at this - probably needed - http://people.csail.mit.edu/eskang/talks/mit-security-seminar-nov2012.pdf .

The specification of XACML:
%http://docs.oasis-open.org/xacml/2.0/access_control-xacml-2.0-core-spec-os.pdf

\section{Problem Statement}

Although XACML has already achieved a considerable degree of industrial acceptance, by itself, it is impossible to determine inconsistencies and apply the fixes to repair the access control model. Inconsistencies exists as an organization may have many such policies, which may have been established at different times, by different people, perhaps without a clear view of all the consequences. 

Determining inconsistencies require verifications and finding counter examples. This process is time consuming depending on the choice of verification and modeling language. Once inconsistencies are found, the user has to apply fixes but there is no guarantee that the fixes can indeed repair the model without introducing new inconsistencies. Thus, the entire model construction process, model verification process/ finding inconsistencies and repairing process can be overwhelming.

In this paper, we propose a tool that we developed that can automatically determine the inconsistencies, recommend the repair to the users and apply fixes to the access control model.

\subsection{Paper structure}
The Design overview section brief overview of our mission and solution to the problem stated; we will introduces the main components of our tool and the implementation approach at different stage. We will then present the implementation details in Implementation section where we articulate our design approach and implementations. Evaluation section contains our experiment results and analysis for the results. In future work section, we discuss about our tool limitations and bring up possible future improvement; expert's comments are also included as a future references. Conclusion section summarizes completed work and the results.

\section{Implementation}

\textcolor{red}{In this section, we present the overview of our implementation, architecture of the tool, alloy model and repair process !!!EDIT}

\subsection{Overview}
The function of our tool is to automatically determined inconsistencies within access control policy defined by XACML, and recommend the potential repair to the user, and finally apply the user chosen fixes automatically. Throughout this process, user only have to review the recommended fixes, and choose the fix by clicking a button in user interface, and then the model should be fixed automatically by our tool. 

To increase the usability of our tool, we have an external module, a converter that can automatically generate Alloy model based on a table template (or xml, csv file template) so that the user does not need to have complete literacy in Alloy modeling language. As the content of the such a template, the user is asked to specify the rule, subject, action, resource and effect in predefined format. Our converter will than generate the Alloy model and its predicate to verify inconsistencies, which is a safetyness property. Once Alloy model is generated, we input the model into our inconsistency detection and repair tool. 

\subsection{Architecture and Data Flow}

Our tool consists of three major parts: user interface, PropertyVerifier\&Fixer and Alloy analyzer. The architecture is shown in the figure below (Fig.\ref{fig:Architecture}) .\\

\begin{figure}[h]
\includegraphics[width=0.5\textwidth]{DataFlow.JPG}
\caption{Tool Architecture and Data Flow}    
  \label{fig:Architecture}
\end{figure}

At start, the UI first takes in the Alloy model created, and sends it to PropertyVerifier\&Fixer. Next, the PropertyVerifier part starts Alloy analyzer to process Alloy model and its property predicate;  please note that , we write our predicate in a way that it checks for if two policies return inconsistent results. PropertyFixer, then takes in the results from Alloy analyzer and extract relevant information, such as inconsistent rules, subject, action, resource and effect, and process those information to propose the potential fixes. The fix recommendation from PropertyFixer is passed to the user interface, and the user is shown with a list of fixes. Once the user chooses one particular fix, our tool will automatically update the original Alloy model. This updated model is then passed to PropertyVerifier to check if there are any inconsistencies. This process is repeated until the model is verified to be consistent.

In order to realize the above mentioned architecture, we have created several Java modules which is summarized below.

\textbf{\emph{InteractiveRepairer}}\\
This is the core of our tool, it contains:
\begin{itemize}
\item Main engine
\item PropertyVerifier
\item PropertyFixer
\end{itemize}
The Main engine, controls the communication between user interface and our Fixer and Verifier; it process input from UI and output the results to UI for user inspection. PropertyVerifier calls Alloy analyzer through our API and obtain XML format of the generated instance that contains information about the policy, rule, request and effect.PropertyVerifier then follows XPATH standard and store those information into nodes for later processing in Java. Once the XPATH nodes are created with relevant information from Alloy analyzer, PropertyFixer takes in those information and proposes potential fixes. Once the user select the preferred fix, this decision is communicated to PropertyFixer again through Main engine, and PropertyFixer will automatically apply the fixes to the original Alloy model.

Note that PropertyFixer and PropertyVerifier function as a pair, and one pair is required for each property to be verified; in our study, we limit the property verification to safetyness property but this is extensible by creating another pair of PropertyFixer and Verifier.

\textbf{\emph{AlloyRunner}}\\
AlloyRunner is an API that facilitate the communication between our tool with Alloy analyzer. Mainly, it initializes the Alloy analyzer, sends model to Alloy analyzer, and get XML instances from Alloy analyzer. Alloy analyzer serves as verification engine for our input model and will return instances or counter example which we use in later processing.

\textbf{\emph{Presentation Layer}}\\
Presentation uses dynamic web application technologies, such as Javascripts, Node.js to allow interactive model repair. Node.js executes interactive repair with user inputs and calls back to the Main engine in InteractiveRepairer to apply the repair. For instance, the propose button triggers Main engine to start PropertyVerifier to execute the model verification, and the resolve button will cause the PropertyFixer to apply the repair on the original Alloy model. The return value associate with each function call-back of the button is error description for propose, and new model for resolve button.


During design phase, we studied all possible ways of fixing the model, and we have chosen four fixes in total considering the efficiency and relevancy of access control policy fix. From experimental results and observation, we decided to prioritize the fixes that modifies the rule effect as it reduces the number of total fixes greatly. The details are presented in the following subsection. 

\subsection{Model Fix}

ToBeAdded

\section{Evaluation Result}

\subsection{Form and purpose}

ToBeAdded

\subsection{Results}
ToBeAdded

\section{Future work}

Although our tool demonstrate potential value in automated access control model repair, while significantly reducing user's manual work, we see future improvements in our tool. During implementation and testing stages, we noticed the following limitations in our tool:

\begin{enumerate}
\item Verification is bounded
\item Can verify one property in a time until first counterexample is found
\item Subset of XACML is covered
\item Repair procedure depends on the property and requires pre-defined prospective repair ways
\end{enumerate}

The first two points are pretty clear; our verification is bounded. Although this enables us to use Alloy as it is for bounded model checking, we would have significant dependability to Alloy. In this case, software upgrade in Alloy would cause potential mul-functioning of our tool which needs to be addressed in the future. In this project, we mainly interfaced the communication with Alloy API therefore, in the future, we need to communicate with Alloy back-end to prevent this problem.

Although we strive to make our tool scalable, the automated Alloy model generation from a user specified table brings limitations in the structure of the model we generate. Although this access control model works well for our present study, it only represents a subset of XACML. In the future, we would like to explore different ways to increase the flexibility of our model. One potential way is to incorporate sketching techniques and having multiple rule tables so that the user can choose the structure of the model our tool generates.

State explosion is not addressed in a smart way due to time constraints. We limit the depth of the potential solution to two. This obviously will become a problem when the examples are large or more complicated. We would like to study more on ways, such as graph theory and multi-object optimization to deal better with this common problem in verification and repair.

One important future improvements is on the repair recommendation. Currently, we only proposes repair based on rule effect and override effect. We derived these to approach from observation and testing. We will explore other factors such as relation, and derivation in the future to enhance our repair framework.

\section{Conclusion}

\subsection{Summary}
In this report, we presented our tool which can automatically determine inconsistencies in XACML access control policy, recommend the fixes to the user and automatically apply the repair on the model. We allow user interaction by an user interface where we display our fixed results, Alloy model and also obtain user input.

We have created the input converter so that user can just specify the policies in our provided format in CSV, table form, and we will automatically generate Alloy model for the access control policy, reducing the manual work and user knowledge on Alloy as a modeling and verification tool. Our tool takes in the Alloy model and run Alloy analyzer in the back-end, and retrieve the information on generated inconsistency instances to propose potential fixes. Among the fixes, we also show the total number of fixes required for the selected fix. From evaluation result, it is proved that our tool can help the user to repair inconsistent access control policy model effectively, requiring only user input for fix selection as a manual part. 

\subsection{Implications}

From our project, we conclude that ``automated'' model repair is possible for access control policy defined by XACML structure. We make implications on the fact that user input is still necessary to reduce the redundant computation and steps taken to fix the model. By allowing user to select from list of recommended fixes, and use the user input as new argument in our automated repair tool, we are able to efficiently repair the model without looping.

One other implication we make is that our tool should be easily extensible so that the model repaired is not limited to access control policy. We see our InteractiveFixer module as a ``head'' which we can change according to the targeted model that needs to be verified. 


\bibliography{sigproc-sp}{}
\bibliographystyle{plain}

\appendix
\section{User experiment tasks and questionnaire} \label{A}

\underline{ \textbf{I. Introductory presentation}}

\underline{ \textbf{II. Tasks}}

Tasks are split into 3 categories: \textbf{Overview}, \textbf{Graph} and \textbf{Case Studies}. All tasks are to be performed using the think-aloud protocol, that is, the participants should verbally describe what and why they are doing. All tasks are based on the file \textit{AndroidSampleMoo\_4.cfr}.

\textbf{1. Overview:}

\textbf{T1.} Upload a model file \textit{AndroidSampleMoo\_4.cfr}.\\
\textbf{T2}. Tell what features and quality attributes are specified in the Android phone model.\\
\textbf{T3}. Tell what objectives are presented in the Android phone model.\\
\textbf{T4}. Tell how many Android phone configurations are generated.\\

\textbf{2. Graph:}

\textbf{T5}. Identify 4 phones with the highest total performance (Just say: “P29, P30, P12, P4”, for instance). What is their total mass?\\
\textbf{T6}. Identify a phone with the lowest energy consumption. What is its total performance?\\
\textbf{T7}. Identify the phones with very low total mass.\\
\textbf{T8}. How many phones have perfect (highest) total security? What features contribute to total security?\\

\textbf{3. Cases studies:}

\textbf{T9.} Your boss says that among all the sets of phones you need to issue only one. He says that he needs to choose one among the phones with the best total performance. He is OK with any high energy consumption, since new Android battery is very good. He says he does not need a perfect total security, but it should be more than 0. So he is OK to sacrifice total security to get more total performance.\\
\textit{Your actions:}\\
1) Which product(s) will you choose and why?\\

\textbf{T10.} Your boss says that it is interesting that bubbles representing P5, P8, P2, and P22 are located close to each other. And he wants to know why this happened. Because, maybe, the phones are equivalent in some sense and we can consider them separately as an equivalence class.\\
\textit{Your actions:}\\
1) What do the products have in common and what are the differences?\\
2) Why the bubbles are located close to each other?\\

\textbf{T11.} Your boss needs you to analyze the total performance and total mass of all prospective phones that have USB and WiFi features. He knows that P5, P8, P2, P22 and P18 have USB and WiFi. But he wants to consider all the phones that have USB and WiFi features.\\
\textit{Your actions:}\\
1) Make the set to be a complete equivalence class by adding other relevant products to it.\\
2) Among the selected products within the equivalence class, what is the:\\
	Minimal,\\
	Mean,\\
	Maximal\\
total performance? Are the phones differ in total mass significantly or not?\\
3) Based on the question above, is it reasonable for the boss sacrifice total mass to gain more total performance?\\

\underline{ \textbf{Questionnaire}}\\

\textbf{Q1.} Do you find the idea of representing the products in a four-dimensional space using bubble chart useful? Any comments on that? Are there limitations? Does the representation of the four dimensions make it easy to find “better” products?\\
\textbf{Q2.} What do you think about the notion of the complete equivalence class? What is it and how it can be used? Describe it in your own words.\\
\textbf{Q3.} I noticed that I can group products together based on their features, so each cluster will be denoted by an equivalence class. Let’s call it “clustering by features”. Do you think it is a good idea or not?\\



\balancecolumns
\end{document}
